- 第一梯度：计算机组成原理、数据结构和算法、网络通信原理、操作系统原理；
- 第二梯度：Java 基础、JVM 内存模型和 GC 算法、JVM 性能调优、JDK 工具、设计模式；
- 第三梯度：Spring 系列、Mybatis、Dubbo 等主流框架的运用和原理；
- 第四梯度：MySQL (含SQL编程)、Redis、RabbitMQ/RocketMQ/Kafka、ZooKeeper 等数据库或者中间件的运用和原理；
- 第五梯度：CAP 理论、BASE 理论、Paxos 和 Raft 算法等其他分布式理论；
- 第六梯度：容器化、大数据、AI、区块链等等前沿技术理论；
- 第七梯度：BAT面经
- 第八梯度：架构师思维及面经, [系统设计](https://github.com/donnemartin/system-design-primer)

# 1. 分布式系统

##  1.1 为什么要进行系统拆分

##  1.2 分布式服务框架

##  1.3 分布式锁

##  1.4 分布式事务

##  1.5 分布式会话



# 2.高并发架构

## 2.1 如何设计一个高并发系统

##  2.2 消息队列

1. 什么场景用的 MQ
2. 你这个系统里为什么要用 MQ
3. 消息队列都有什么优缺点
4. Kafka, activeMQ, rabbitMQ, rocktMQ都有什么区别 
5. 如何保证消息队列的高可用
6. 如何保证消息不被重复消费？如何保证消费的时候是幂等的？
7. 如何保证消息的可靠性传输，要是消息丢了怎么办？
8. 如何保证消息的顺序性？
9. 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万条消息持续积压了几个小时，说说怎么解决？
10. 如果让你写一个消息队列，该如何进行架构设计？说一下思路



##  2.3 搜索引擎

##  2.4 缓存

1. 在项目中缓存是怎么使用的？
   
   - 结合自己项目的业务来
   
2. 为什么在项目里面要用缓存？
   - 主要两用途：高性能，高并发
   - 高性能：
     - 比如一个请求过来，全部操作数据库，很久才查出一个结果，耗时600ms。但是这个结果在接下来几个小时都不变。这样就可以将这个数据放在缓存里面，后面请求访问的时候直接走缓存，这样节省了查询数据库的时间。
   - 高并发：
     - MySQL 单机支撑到2000QPS 也开始容易报警了。如果有个系统在高峰期一秒钟有一万个请求，单机的 MySQL 肯定会死掉。这个时候就用缓存，把很多数据放缓存里，这样单机并发量轻松到每秒几万到几十万。单机承载并发量是 MySQL 单机的几十倍。
   
3. 用了缓存后会有什么不良后果？
   - 缓存与数据库双写不一致
   - 缓存雪崩
   - 缓存穿透
   - 缓存并发竞争
   
4. redis 和 memcached 有什么区别？ redis 的线程模型是什么？为什么单线程的 redis 比多线程的 memcached 效率高得多？
   - 核心是基于非阻塞的 IO 多路复用机制
   - 纯内存操作
   - 单线程反而避免了多线程的频繁上下文切换
   
5. redis有哪些数据类型？分别在哪些场景下使用比较合适？
   - String 字符串
     - 普通的 set，get，做简单的 kv 存储
     - string 类型的值最大能存储 512MB
     - 常规key-value缓存应用。常规计数: 微博数, 粉丝数。 实现方式：String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。
   - hash 哈希
     - **Hash** 是一个键值(key => value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象（应用对象包含多种属性, 但是没有嵌套其他对象）。
   - list  列表
     -  list列表是简单的字符串列表，按照插入顺序排序(内部实现为LinkedList)，可以选择将一个链表插入到头部或尾部。
     - 消息队列系统：使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。比如：将Redis用作日志收集器，实际上还是一个队列，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。
     - 列表最多可存储 2^32^ - 1 元素 
   - set 集合
     - **set** 是string类型的无序集合。集合是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。所以添加，删除，查找的复杂度都是O(1)。
     - Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了**判断**某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。
     - 如果需要对一些数据进行快速的全局去重，可以基于 JVM 的 HashSet 去重。但是如果某个系统是部署在多台机器上，得基于 redis 进行全局的 set 去重。
   - zset 有序集合
     - **zset** 和 set 一样也是string类型元素的集合,且不允许重复的成员。 *zadd 命令：*添加元素到集合，元素在集合中存在则更新对应score。 常用命令：zadd,zrange,zrem,zcard等
     - 1、排行榜 2、带权重的消息队列
   
6. redis 过期策略都有哪些？内存淘汰机制有哪些？手写一下 LRU 代码实现

   - 过期策略：

     - 定期删除 + 惰性删除

   - 内存淘汰机制：

     - Noeviction: 当内存不足以容纳新数据时，写入会报错
     - allkeys-lru : 当内存不足以容纳新数据时，移除最近最少使用的key（**最常用的设置**）

     - Allkeys-random : 当内存不足以容纳新数据时，随机移除一个key

     - volatile-lru : 当内存不足以容纳新数据时，在设置了过期时间的键空间中，移除最近最少使用的key

     - volatile-random : 当内存不足以容纳新数据时，在设置了过期时间的键空间中，随机移除key

     - volatile-ttl : 当内存不足以容纳新数据时，在设置了过期时间的键空间中, 有更早过期时间的key优先删除

7. 如何保证redis高并发和高可用？redis主从复制原理能介绍下吗，redis哨兵模式原理能说一下吗？

   - redis replication (主从复制) ---> 读写分离（master写，slave 读）---> 水平扩容支撑读高并发
     - redis replication 核心原理
       - redis采用异步方式复制数据到slave节点，从2.8开始，slave node会周期性的确认自己每次的复制的数据量
       - 一个master node是可以配置多个slave node
       - slave node也可以连接其他slave node
       - slave node做复制的时候，是不会blocak master node的正常工作的
       - slave node做复制的时候，也不会blocak自己的查询操作，它会旧的数据集来提供服务。但是数据复制完成，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了。
       - slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量。
     - master node持久化对于主从架构安全保障的意义
       - 如果采用了主从架构，那么建议必须开启master node 的持久化。
       - 不建议使用slave node作为master node的数据热备份。因为那样的话，你关掉master的持久化，可能在master宕机重启的时候数据是空的，然后可能一经过复制，slave的数据也丢了。
       - 即使使用高可用机制，slave node可以自动接管master node，但是也可能sentinal还没有检测到master failure，master node就自动重启了。还是可能导致前面提到的slave node数据情况故障。

## 2.5 分库分表

##  2.6 读写分离



# 3.高可用架构

##  3.1 如何设计一个高可用系统

##  3.2 限流

##  3.3 熔断

##  3.4 降级

